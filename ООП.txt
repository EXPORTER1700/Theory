1. Основные особенности ООП
ООП - объектно ориентированое програмирование - это подход, при котором вся программа рассматривается как набор 
взаимодействующих друг с другом объктов. При этом на важно знать их характеристики. У каждого объекта есть свойста и методы.
Принципы ООП:
-Инкапсуляция - сокрытие поведения объекта внутрь него. То есть мы должны скрывать логику внутрь объкта , а наружу
лишь отдавать интерфейс с четко описанным сценарием работы с этим объектом. 
-Наследование - выделение общих свойств у нескольки объектов и вынесение их в другой объект. Затем с помощью наследования мы можем получить доступ к этим свойствам.
-Полиморфизм - принцип «один интерфейс — множество реализаций». Заключается в переопределении поведения. То есть 
если у нескольких объектов есть одинаковый метод , но работает он по разному - мы переопределяем его.

2. Класс и Объект различия.
Класс является описанием объекта , его состояния и поведения , а объект является конкретным воплощением экземпляра класса.
Класс создается с помощью  ключевого слова class , а объект создается с помощью ключеого слова new и вызова класса.
Поля в классе которые хранят какое-то описание сущности называются свойствами.
Функции в классе называются методами.
Обращение к свойствам и методам внутри класса производится с помощью ключевого слова this.
В классах есть constructor - это функция которая будет вызвана в момент создания экземпляра класса (объекта).
Классам доступно аследование с помощью ключевого слова extends. Класс может наследоваться только от одного класса.
Для получения доступа к свойствам и методам из класса от которого было произведено наследование используется ключевое слово super.
Свойства и методы можно обозначить специальными модификаторами доступа:
-private - делает свойство приватным , то есть доступ к нему можно получить только в рамках этого класса.
-public - значение по умолчанию , означает что доступ к свойству или методу можно будет получить в любом месте кода
-protected - обозначает что свойство или метод будут доступны только в рамках этого класса и в рамках классов которые будут наследоваться от него.
Так же есть дополнительные модификаторы:
readonly - свойство доступно только для чтения , нельзя переопределить
static - дает возможность получать доступ к методу или свойству без создания экземпляра класса (объекта).

3. Типы наследования в JS
Существует 3 типа наследования: 
-Прототипное наследование. В этом случае в прототип создаваемого объекта будут помещены свойста и методы наследуемого объекта.
-Псевдоклассическое наследование. 
-Функциональное наследование.Устаревший метод. Использовался до появления классов. Синтаксис таков что в функции конструкторе мы вызываем другую функцию
от которой хотим унаследоваться и с помощью apply задаем контекст this.

4. Superclass vs subclass.
Superclass - родительский класс от которого происходит наследование
Subclass - дочерний класс который наследуется от superclass

5. Static vs Dinamic polymorphism
Статический полиморфизм - заключается в перегрузке методов. Привязка метода между вызовом метода и определением метода 
происходит во время компиляциии зависит от ссылки на класс.
Динамический полиморфизм - переопределение методов. Привязка метода между вызовом метода и определением метода происходит во время выполнения и зависит от объекта класса.

6. Перегрузка и переопредление методов.
Переопредление методов заключается в том что если мы объявляем два метода с одинаковым названием - последняя определенная
версия переопределит ранее определенную версию и каждый раз когда будет выполняться функция - будет выполняться последняя определенная версия.

Перегрузка методов. JS не поддерживает перегрузку методов , но она становится нам доступна благодаря TypeScript.
Смысл перегрузки заключается в описании сигнатуры вызова без тела самой функции.
greet(person: string): string;
greet(persons: string[]): string[];
greet(person: unknown): unknown {
    if (typeof person === 'string') {
      return `${this.message}, ${person}!`;
    } else if (Array.isArray(person)) {
      return person.map(name => `${this.message}, ${name}!`);
    }
    throw new Error('Unable to greet');
  }
}

7. Инкапсуляция и модификаторы доступа.
Инкапсуляция - это сокрытие свойств и методов внутрь объекта и предоставление клиенту интерфейса для удобного взаимодействия с объектом.
Простыми словами для того что бы зехать на машине - нам не нужно знать как работает двигатель под капотом.
Есть 3 модификатора доступа: 
-private - делает свойство приватным , то есть доступ к нему можно получить только в рамках этого класса.
-public - значение по умолчанию , означает что доступ к свойству или методу можно будет получить в любом месте кода
-protected - обозначает что свойство или метод будут доступны только в рамках этого класса и в рамках классов которые будут наследоваться от него.

8. Абстрактные классы.
Абстрактный класс определяется с помощью ключевого слова abstract перед словом class
Абстрактные классы отличаются от обычных лишь тем что от них нельзя создать экземпляр класса. На пример:
есть класс Фигура , и есть классы Треугольник , Круг и Квадрат которые наследуются от Фигуры. Класс Фигура является чисто абстрактным , так как сама по 
себе фигура не может существовать , а вот Треугольник , Круг и Квадрат уже могут существовать поэтому они будут обычными классами.

9. Интерфейс.
Интерфейс - макет объекта. Описывает какие должны быть свойства и методы в объекте , а так же их типы.
Интерфейс может наследоваться от другого интерфейса , причем если класс может наследоваться только от одного суперкласса , 
то интерфейс может быть унаследован сразу от нескольких других интерфейсов.
Так же от интерфейса мы можем имплементировать класс, тем самым мы говорим что класс должен обязательно
содержать набор свойств и методов объявленных в интерфейсе , но так же может и содержать уже какие-то свои свойства и методы.

10. Constructor
По факту constructor это обычный мотод в классе. Этот метод вызывается в момент когда мы создаем экземпляр класса 
с помощью new. То что мы передадим в круглых скобках во время создания как раз таки попадет в конкструктор в качестве аргументов.
В случае если мы наследуем класс и хотим получить доступ к свойствам из суперкласса мы должны вызывать метод super
и передать туда необходимые аргументы.

11. SOLID
