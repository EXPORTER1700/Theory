Basics

1. Типы данных
-String - Строка
-Number - Число
-Bigint - Большое число, объявляется с помощью n в конце числа
-Boolean - Логическое значение, true или false
-null - Обозначает "Ничего", задается вручную
-undefined - Обозначает что переменная объявлена , но ей не присвоено значение.
-symbol - это уникальное и иммутабельное примитивное значение, которое может быть использовано как ключ 
для свойства объекта
-object - Все вышеуказанные типы данных являются примитивами , object же является сложным типом данных. 
К нему относят Объекты , Массивы , Функции , Date и тд.

2. var, let, const
var - устаревший способ объявления переменной. Основные особенности:
-Можно переопределять значение
-Можно обратиться к переменной еще до объявления , в таком случае получим не ошибку , а undefined. Если говорить терминами -
переменные объявленные с помощью  var всплвают , то есть компилятор JS сначала проходит по коду , собирает все переменные var,
декларирует их , а затем идет по коду и приваивает им значение.
-Не ограничивается блоками if и for , то есть переменная объявленная внутри этих блоков будет доступна и за их пределами.

let - появился в стандарте ES6. Основные особенности.
-Как и в случае с var можно переопределять значение
-Не всплывает , то есть если обратимся к переменной до ее объявления - получим ошибку.
-Видимость ограничивается любым блоком

const - появился в стандарте ES6. Константное значение. Отличается от let лишь тем что нельзя переопределять значение (конкретно значение,
то есть если мы говорим о ситуации когда в константу назначен объект и мы меняет какое-то поле у этого объекта - это
сработает , так как ссылка на объект останется прежней , но если мы захотим переопределить само значение переменной - получим ошибку.)

3. Хостинг - процесс всплытия. Характерен для пременных объявленных с помощью ключевого слова var , а так же для функций объявленных 
с помощью function diclaration. Сам процесс заключается в том что компилятор JS сначала проходит по коду , декларирует переменные и функции ,
а уже затем идет по коду и присваивает им значение. Благодаря этому процессу мы можем обращаться к функциям еще до их объявления.

4. == vs ===
Не строгое и строгое равенство.
При не строгом равенстве мы сравниваем по значению с приведением типов к одному общему. При строгом равенстве приведение 
типов не происходит и если у двух значений изначально разные типы - мы сразу получим false.

5. Неявное приобразование типов.
При явном приобразовании типов мы приобразовываем с помощью глобальных объектов , то есть например что бы приобразовать
строку '123' к число мы поступим следующим образом - Number('123').
Неявное приобразование происходит за кулисами js , например когда мы в блоке if в круглых скобках передаем просто переменную
let foo = '123'
let bar = 0
if(foo) //foo приведется к boolean типу и вернет нам true так как строка не пустая
if(bar) //bar приведется к boolean типу и вернет false так как 0 это всегда ложное значение
Еще примеры неявный преобразований:
- Приобразование с помощью унарного плюса перед значением - приобразует значение к числу
- Двойное отрицание - приобразует значение к boolean типу

6. Передача по значению и по ссылке.
В JS по значению передаются примитивные типы данных, по ссылке передаются объекты , массивы , функции.
Грубо говоря передача по ссылке заключается в том что объект создается где-то внутри js , а в переменную присваивается
ссылка по которой мы получаем доступ к этому объекту.
При сравнении объектов или массивов сравниваются ссылки на них , то есть если у нас есть два объекта абсолютно идентичных по структуре ,
но у них разные ссылки - это сравнение вернет false.
Так же если мы в переменную присваиваем другую переменную в которой хранится ссылка на объект - то и в новую переменную мы присвоим ссылку на 
этот объект. И в дальнейшем если мы будем обращаться к объекту который находится в этой переменной - мы будем обращаться как раз
таки по ссылке и изменять тот объект которому эта ссылка принадлежит.
let obj = {
 a: 12
}
let obj2 = obj
obj2.a = 42
console.log(obj) // {a: 42}
console.log(obj2) // {a: 42}

7. NaN, Infinity, -Infinity
Все эти значения относятся к типу данных Number.
NaN - Not a number. Говорит о том что значение не является числом. Появляется в результате неверных математических операций , например умножения числа на строку.
Infinity and -Infinity - обозначает положительную и отрицательную бесконечности. Любое число умноженное на бесконечность возвращает бесконечность,
а любое число деленное на бесконечность - возвращает 0

8.Immediately Invoked Functions (IIFE)
Представляют собой анонимную самовызывающуюся функцию. Имеют следующую конструкцию: функция оборачивается в круглые скобки , а затем ставятся еще одни круглые скобки которые эту функцию сразу же и вызывают.

9, 10. this
Ключевое слово которое позволяет ссылаться на котекст вызова. Но так же this можно задать и вручную с помощью  методов call, apply, bind
call - вызывает функцию с заданным конекстом, прнимает сам конекст и затем через запятую перечисляются аргументы функции.
apply - вызывает функцию с заданным контеском, принимает сам контекст , а так же массив в котором идет перечисление аргументов функции.
bind - возвращает новую функцию с заданным контеском. Принимает сам контекст и через запятую перечисляются аргументы функции.


11. Scope , scope chaining
Простыми словами scope это доступность переменных в рамках блока. Мы можем получать доступ к переменным из текущего блока и всех вышестоящих блоков и 
не можем получать доступ к переменным которые находятся в нижестоящих блоках.

12. Замыкания
Замыкание - это функция, содержащая в себе ссылки на переменные из внешней области видимости. Т.е. она "замыкает" внешние переменные в себе.
Если еще более простыми словами - это функция которая возвращает функцию. Самый банальный пример это счетчик.

13. Prototypes and prototypal inheritance
По факту весь JS построен на прототипном наследовании. У каждого создаваемого объекта автоматически создается ключ Prototipe в котором лежит ссылка на другой объект 
у которого так же есть Prototipe. Финальным в этой цепочке будет глобальный объект window.
Когда мы обращаемся к какому либо свойству или методу в объекте - мы сначала ищем его в самом объекте , затем в прототипе и так дальше
по цепочке. Если мы доходим до глобального объекта window и не находим нужное свойство и так - в таком случае мы получаем ошибку.
Так же прототип можно задать вручную с помощью ключа __proto__ 

14. Constructor function
Функция конструктор - функция которая возвращает нам новый объект. Есть несколько правил:
-Имя должно начинаться с большой буквы
-Функция констрктор должна вызываться с помощью ключевого слова new
Функции конструкторы устаревший вариант, с появлением ES6 их заменили классы.

15. Regex 
Регулярные выражения - то что все по необходимости гуглят:)