Basics

1. Что такое TS и какие его преимущества.
Typescript является надстройкой над JS. Главным преимуществом TS является возможность явно задавать типы для наших переменных. 
Это помогает нам избежать ошибок не на этапе компиляции, а еще на этапе разработки. Так же огромным плюсом является мощный автокомплит.

2.Базовые типы. 
-String 
-Number
-Boolean
-Tuple - [string , number] - означает массив который будет содержать на нулевом индексе строку , а на первом индексе число
-Enum
-Unknown - Обозначает неизвестный тип. В дальнейшем с помощью проверок на тип мы можем его конкретизировать.То есть
в данном случае TS будет требовать проверку на тип , а не будет думать что переменная у нас любого типа.
-Any - Обозначает любой тип. То есть в дальнейшем TS не будет т ребовать каких либо проверок на тип и будет для себя
понимать что переменная может быть абсолютно любого типа.
-Null 
-Undefined
-Never - есть два случая в которых использхуется этот тип - когда функция вызывает ошибку с помощью throw или когда 
в функции крутится бесконечный цикл , например whilt(true)
-Object

3. Строгость
strict- Устанавливает максимальную строгость, устанавливая все флаги ниже на true.
noImplicitAny- Вызывает ошибку в выражениях и объявлениях с предполагаемым типом any.
noImplicitThis- Вызывает ошибку в this выражениях с предполагаемым типом any.
strictBindCallApply- Включает строгую проверку методов bind, call и applyфункций.
strictNullChecks- Означает, что null и undefinedзначения не являются допустимыми значениями в типах.
strictFunctionTypes- Отключает бивариантную проверку параметров для типов функций.
strictPropertyInitialization- Гарантирует, что свойствам класса присваиваются значения по умолчанию или инициализируются в конструкторе.
alwaysStrict- Анализирует код в строгом режиме JavaScript и выдает «use strict» в транспилированном коде.

4. Явные и не явные типы.
В TS мы можем как задать тип переменной явно , так и расчитывать на то что умный компилятор за кулисами сам определит
тип переменной. Допустим в случае объявления переменной без явного  указания типа и присвоения ей строки TS автоматически
определит тип этой переменной как string.
let foo = 'какая-то строка' 
foo = 123 //Ошибка , тип переменной foo был автоматически определен как string

5. Union types 
Юнион типы позволяют нам сказать TS о том что переменная может быть как одного типа , так и другого.  Объединение 
происходит с помощью вертикальной черты |. Простыми словами вертикальную черту можно читать как ИЛИ.
function foo(arg: string | number): void{ //arg может быть строкой ИЛИ числом.
  console.log(arg)
}
foo('bar')
foo(123)
foo(true) //Ошибка , arg может быть только строкой или числом

6.Type aliases vs interface
Aliases types позволяет задать имя для определенного типа. Например type numberOrStrin = number | string. 
let foo: numberOrString = 123
let foo: numberOrString = 'bar'
let foo: numberOrString = true // Ошибка
Основным отличием от интерфейсов является возможность работать как с примитивами , так и с объектами.

Interface 
Позволяют описать структуру объекта.
interface Foo{
  a: string
  b: number
}
let obj: Foo = {
  a: 'bar',
  b: 123
}
Основным отличием от типов является невозможность работать с примитивами, так же интерфейсы могут наслудоваться с 
помощью ключевого слова extends, имплементироваться с помощью ключемого слова implements , а так же описывать струтуру классов.

7. Литеральные типы.
Позволяют явно задать не тип переменной, а конкретное ее значение. В данный момент поддерживается со строками , числами и boolean.
type Statuses = 'success' | 'error'
function foo(status: Statuses): void{
  console.log(status)
}
foo('success')
foo('error')
foo('unauthorized') //Ошибка , status может иметь значение только 'success' или 'error'

8. Enum 
Конструкция которая позволяет нам работать с перечислениями. По умолчанию enum компилируется в iife функцию в любом случае , даже если он объявлен и нигде не используется, 
но если объявить его через const то он будет компилироваться только в том случае если он где-то используется.
Если в enum мы просто перечисляем значения - они будут доступны по ключам как в массиве. Если же мы присваиваем какие-то
значения - потом мы можем обращаться к ним по ключу как в объекте.
Enum Statuses {
 SUCCESS = "Success",
 ERROR = "Error"
}
const success = Statuses.Success // "Success"

function foo(status: Statuses): void{
  console.log(status)
}
foo(Statuses.SUCCESS)
foo(Statuses.ERROR)
foo('Success') //Ошибка , хоть значение и присутствует в enum , но передавать его нужно явно как в примерах выше
foo('unauthorized') //Ошибка , status может быть только значением которое содержиться в enum Statuses

9. Narrowing
  In - позволяет определить что значение содержиться в объекте как ключ.
  const obg = {
    a: 'foo'
  }
  if('a' in obj) {
    console.log(obj.a)
  }

  Is - позволяет сказать что значение является boolean и обозначает имеет ли наше значение определенный тип.
  function isString(test: any): test is string{
    return typeof test === "string";
  }

10. Function type expressions
В TS для описания функций используется синтаксис похожий на стрелочные функции.
interface Foo{
 sum: (a: number,b: number) => number
}
const obj: Foo = {
 sum: (a,b) => a + b
}

11. Опциональные параметры.
В TS мы можем указать что параметр является не обязательным с помощью знака вопроса.
interface Foo {
 a: string
 b?: number
}
const obj: Foo = {
 a: 'hello'
}
const obj2: Foo = {
 a: 'hello',
 b: 123
}

12. This
this - ключевое слово которое позволяет нам ссылаться на котекст вызова. Работа с this в TS такая же как и в JS.

13. Extending types
Наследование типов в TS происходит с помощью ключевого слова extends. Доступно для интерфейсов и абстрактных классов. 
При наследовании мы говорим что наследуемый тип будет содержать свойства из того  типа который он наследует плюс свойства которые мы можем
ему добавить (не обязательно , так как бывают случаи когда у нас есть два интерфейса и мы хотим создать интерфейс который
будет содержать все поля из тех двух интерфейсов)
intrface Foo{
 a: string
}
interface Bar{
 b: number
}
intrface FooBar extends Foo, Bar // Под капотом интерфейс FooBar будет иметь такой вид {a: string, b: number}

interface Some extends Foo{ // Под капотом интерфейс Some будет иметь такой вид {a: string, c: boolean}
 c: boolean
}

14. Intersection types
Используется с помощью амперанда &. Говорит что тип будет содержать несколько типов.
Своего рода наследование , но не с interface , а с type
type foo = {
 a: string
}
type bar = {
 b: number
}
type foobar = foo & bar // Под капотом будет иметь вид {a: string , b: number}