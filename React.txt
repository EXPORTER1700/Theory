Мемоизация - кеширование данных которые не нужно пересчитывать каждый раз, а только в определенном случае.

React Hooks
-useState - хук для управления состояния компонента. Принимает initial value , возвращает кортеж из двух элементов ,
первый - значение состояния , второй - функция для изменения этого состояния. Изменять состояни на прямую нельзя.
-useEffect - хук для управления жизненным циклом компонента. Принимает callback функцию и массив зависимостей. 
Что бы callback функция отработала при первичном рендере элемента - передается пустой список зависимостей.
Что бы callback функция отработала при опредленных изменениях - добавляем их в список зависимостей.
Что бы callback функция отрабатывала при любых изменениях - не передаем список зависимостей.
Что бы выполнить какие либо действия пи размонтровании элемента - передаем пустой список зависимостей и из callback функции
возвращаем новую функцию , тело этой функции будет выполнено при размонтировании элемента.
-useMemo -предназначен для мемоизации значения. Принимает callback функцию и список зависимостей. Если передать пустой спиоск
зависимостей - значение посчитается один раз при первичной отрисовке , если помещаем какие-либо переменные в спиос зависимостей - значение
будет пересчитано при их изменении.
-useCallback - то же самое что и useMemo , но мемоизирует не значение , а саму функцию
-useRef - предназначен для получения ссылки на определенный элемент. Принимает initialValue , а возвращает объект
в котором по ключу current будет лежать ссылка на элемент которому в качестве атрибута "ref" мы укажем объект который вернул хук.

1. JSX - синтаксис который позволяет работать с javascript кодом в виде html. По умолчанию для создания элементов 
в Реакт используется встроенный метод React.CreateElement который принимает название элемента , дочерний элемент 
и набор свойст (props). Такой синтаксис менее привычен и к тому же на большом уровне вложенности все становится запутанным, 
а JSX эту проблему как раз таки решает.
2. Компоненты с состоянием и без. В React компонент может хранить в себе состояние , для этого в версии React 16.8 
появился хук useState (до этого работа с состоянием осуществлялась с помощью  this.state в классовых копонентах).
Само состояние представляет из себя какое либо динаическое значение от которого зависит компонент. Компоненты без
состояния обычно являются UI компонентами , которые не несут в себе какой-либо логики.
3. VirtualDOM - концепция разработанная для более эфективного рендера в React. Как известно самыми трудозатратными операциями
в JS являются операции с DOM. По умолчанию когда мы вносим какие либо изменения в наш html с помощью js - дерево
дом элементов каждый раз заново перестраивается. Virtual DOM представляет из себя копию оригинального DOM. Когда мы вносим
какие либо изменения в React (изменяется состояние или пропсы) - изменения сначала вносятся в Virtual DOM (если в 
рамках одного выполнения функции происходит изменения нескольких состояний - React их "накапливает пачками" и затем разом
все вносит. Затем с помощью алгоритном просходит сравнение оригинального DOM и Virtual DOM и изменения вносятся только в те 
места где они действительно необходимы.
4. В react есть два вида связывания элемента: одно и двух стороннее. 
-Одностороннее связывание происходит с помощью хука useRef. С помощью него в поле current мы получаем ссылку на 
ноду и затем можем к ней как-то обращаться.
-Двухстороннее связывание происходит с помощью хука useState. Суть заключается в том что состояние является value для input,
а при изменении состояния мы заменяем value на новое значение из input.
5. Ключи и списки. Для отрисовки списков в реакт мы можем прямов внутри JSX разметки с помощью map пройти по массиву значений
и на основании их отрисовать нужный элемент для каждого. В таком случае React просит для каждого отрисованного элемента списка задать key 
который должен быть обязательно уникальным в рамках одного списка (не рекомендуется использовать индекс элемента если
подразумевается что список может меняться , в таком случае и индексы будут меняться и React не сможет эфективно рендерить
страницу). Нужен ключ для того что бы React мог правильно отслеживать изменения в списке. По умолчанию для всех
элементов react задает ключи под капотом , но для динамически отрисованного списка он этого сделать не может. Ключ вручную можно задать
и для обычного элемента. Например если нужно сделать так что бы элемент вообще никогда не перерендеривался - задаем статичный ключ, 
например 1. Если нужно вызывать рендер компонента из родительского компонента - можем создать в родительском компоненте 
состояние key и назначить его как key нужному элементу , а затем в момент когда нужно произвести ререндер - изменить key на 
math.random()
6. Рендер элемента просиходит при первичной отрисовке и так же при изменении каких либо пропсов или состояния внутри компонента.
При рендере мы каждый раз проходим по функции сверху вниз , то есть каждый раз пересоздаются функции , переменные и тд которые есть 
в теле функции , затем jsx разметка которая возаращается из функции передаются в функцию ReactDOM.render и происходит перерисовка компонента.
7. State и Props. 
Props - набор свойст которые принимает компонент как аргументы.
State - какое-то внутренее состояние компонента.
При изменении props или state происходит ререндер компонента.
8. HOC - компоненты высшего порядка - компоненты которые принимают другие компоненты как props и возвращают новый компонент. 
Например какая-либо обертка для компонента которая имеет внутри себя определенное состояние. Грубо говоря HOC добавляют новый
функциоал в передаваемый в него компонент.
9. Методы жизененного цикла в React.
-Component will mount
-component did mount
-component should update
-component did update
-componetn will unmount
В функциональном же реакте для управления жизненным циклом компонента используется хук useEffect.
10. Redux - библиотека для управления состоянием. Решает такие проблемы как props drelling и позволяет получать
доступ к опредленным значениям из любого места в коде. 
Термины:
store - объект который хранит в себе все записанные в него значения.
action - объект с обязательным полем type и необязательным payload. В зависимости от type определяется какие именно
нужно вносить изменения , в payload находятся данные переданные пользхователем необходимые для изменения состояния.
Reducer - чистая функция которая принимает action и на его основании обновляет состояние.
dispatch - своего рода диспетчер который принимает action и передает его в reducer. Что бы получить dispatch редакс 
предоставляет хук useDispatch
slice - термин уже из redux toolkit , представляет из себя объект который позволяет в более удобной форме работать с redux.

Работа с redux:
-в функции рендер копонент App необходимо обернуть в Provider и вв качестве пропс передать store
-store создается с помощью функции configStore , которая принимает объект куда ы передаем корневой редюсер по ключу reducer
и middleware
-корневой редюсер создается с помощью функции combineReducer которая принимает объект в котором находятся все редюсеры
-Создается слайс с помощью createSlice , которая принимает объект с полями name (уникальное имя слайса), initialState и reducers (объект 
в котором создаются непоредственно редюсеры)
-Что бы создать редюсер в переменную назначаем slice.reducer
-Что бы получить все actions - с помощью деструктуризации из поля slice.actions достаем все экшены
-Что бы вызвать экшен - в функциональном компоненте создаем dispatch с помощью хука useDispatch , а затем вызываем
dispatch и передаем туда необходимый action
11. React Routing
роутинг предназначен для управления навигацией по приложению SPA (Single Page Aplication)
для работы с роутингом используются библиотеки react-router и react-router-dom
Нужно обернуть компонент App BrowserRouter
Корневым блоком для роутов служит элемент Routes
Туда вкладываются уже элементы Route
Route принимает path (путь) и element который будет отрисован по этому пути.
Для навигации используется либо Link , либо функция navigate получаемая из хука useNavigate.

12. Стили в React можно задавать как инлайн , так и в отдельном css файле. Для задания inline стилей в пропс 
style передается объект в котором идет перечисление css свойств в camelCase. Можно задавать и глобальные стили 
доступ к которым будет у всех компонентов.
Удобным подходом к написанию стилей являются css модули , при таком подходе к классам добавляется уникальный хеш 
что позволяет нам писать стили индивидуально для ккаждого компонента не боясь что они будут применены в другом компоненте.
